<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Motion Arena â€” Controller</title>
    <link rel="stylesheet" href="css/common.css">
    <style>
        html,
        body {
            height: 100%;
            overflow: hidden;
            touch-action: none;
        }

        .controller {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 16px;
            position: relative;
        }

        /* Header */
        .ctrl-header {
            text-align: center;
            padding: 12px 0;
            flex-shrink: 0;
        }

        .ctrl-header h1 {
            font-family: var(--font-retro);
            font-size: 0.7rem;
            color: var(--accent-cyan);
            letter-spacing: 2px;
        }

        .ctrl-header .player-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 14px;
            border-radius: 20px;
            margin-top: 8px;
            font-family: var(--font-retro);
            font-size: 0.55rem;
            letter-spacing: 1px;
        }

        .ctrl-header .player-badge.p1 {
            background: rgba(0, 229, 255, 0.1);
            border: 1px solid rgba(0, 229, 255, 0.3);
            color: var(--accent-cyan);
        }

        .ctrl-header .player-badge.p2 {
            background: rgba(255, 0, 229, 0.1);
            border: 1px solid rgba(255, 0, 229, 0.3);
            color: var(--accent-magenta);
        }

        /* Camera Container */
        .camera-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            border-radius: var(--radius-lg);
            overflow: hidden;
            margin: 12px 0;
            background: #000;
            border: 1px solid var(--border-subtle);
        }

        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
        }

        #canvas-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* Gesture Display */
        .gesture-display {
            position: absolute;
            bottom: 16px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 12px 24px;
            border-radius: var(--radius-md);
            border: 1px solid var(--border-accent);
            text-align: center;
            z-index: 10;
            min-width: 180px;
        }

        .gesture-display .gesture-icon {
            font-size: 2rem;
            margin-bottom: 4px;
        }

        .gesture-display .gesture-name {
            font-family: var(--font-retro);
            font-size: 0.6rem;
            color: var(--accent-cyan);
            letter-spacing: 2px;
        }

        /* Status Bar */
        .status-bar {
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 0;
            font-size: 0.8rem;
        }

        .status-bar .connection {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-secondary);
        }

        .status-bar .fps {
            font-family: monospace;
            color: var(--text-muted);
            font-size: 0.75rem;
        }

        /* Connection Screen */
        .connecting-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            text-align: center;
            padding: 24px;
        }

        .connecting-screen h2 {
            font-family: var(--font-retro);
            font-size: 0.8rem;
            color: var(--text-primary);
            margin-bottom: 16px;
        }

        .connecting-screen p {
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-bottom: 24px;
        }

        .connecting-screen .error {
            color: var(--accent-red);
        }

        /* Waiting screen */
        .waiting-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 10, 15, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 50;
            text-align: center;
            padding: 24px;
            display: none;
        }

        .waiting-overlay.visible {
            display: flex;
        }

        .waiting-overlay h2 {
            font-family: var(--font-retro);
            font-size: 0.8rem;
            color: var(--accent-green);
            margin-bottom: 12px;
        }

        .waiting-overlay p {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        /* === KNIGHT DASH MOTION CONTROLLER === */
        .motion-controller {
            display: none;
            flex-direction: column;
            height: 100vh;
            padding: 16px;
            position: relative;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        .motion-controller.visible {
            display: flex;
        }

        .motion-header h1 {
            font-family: var(--font-retro);
            font-size: 0.7rem;
            color: var(--accent-green);
            letter-spacing: 2px;
            margin-bottom: 8px;
        }

        .motion-header .game-badge {
            display: inline-block;
            padding: 4px 14px;
            background: rgba(83, 215, 105, 0.1);
            border: 1px solid rgba(83, 215, 105, 0.3);
            border-radius: 20px;
            font-family: var(--font-retro);
            font-size: 0.5rem;
            color: var(--accent-green);
            letter-spacing: 1px;
            margin-bottom: 24px;
        }

        .jump-zone {
            width: 220px;
            height: 220px;
            border-radius: 50%;
            border: 3px solid rgba(83, 215, 105, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 20px 0;
            transition: all 0.15s;
            background: rgba(83, 215, 105, 0.05);
        }

        .jump-zone.active {
            border-color: var(--accent-green);
            background: rgba(83, 215, 105, 0.15);
            box-shadow: 0 0 60px rgba(83, 215, 105, 0.3);
            transform: scale(1.08);
        }

        .jump-zone .jump-icon {
            font-size: 4rem;
            margin-bottom: 8px;
        }

        .jump-zone .jump-label {
            font-family: var(--font-retro);
            font-size: 0.7rem;
            color: var(--accent-green);
            letter-spacing: 3px;
        }

        .accel-bar {
            width: 80%;
            max-width: 280px;
            height: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            overflow: hidden;
            margin: 16px 0;
            border: 1px solid var(--border-subtle);
        }

        .accel-bar-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--accent-green), var(--accent-cyan));
            border-radius: 6px;
            transition: width 0.1s;
        }

        .motion-hint {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-top: 16px;
            line-height: 1.5;
        }

        .jump-count {
            font-family: var(--font-retro);
            font-size: 0.55rem;
            color: var(--text-muted);
            letter-spacing: 2px;
            margin-top: 16px;
        }

        .motion-status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            background: rgba(10, 10, 15, 0.8);
            border-top: 1px solid var(--border-subtle);
            font-size: 0.75rem;
        }

        .motion-status-bar .connection {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-secondary);
        }

        /* === GHOST BREATH CONTROLLER === */
        .ghost-controller {
            display: none;
            flex-direction: column;
            height: 100vh;
            padding: 16px;
            position: relative;
            align-items: center;
            justify-content: center;
            text-align: center;
            background: linear-gradient(180deg, #0a0814, #120a20);
        }

        .ghost-controller.visible {
            display: flex;
        }

        .ghost-header h1 {
            font-family: var(--font-retro);
            font-size: 0.65rem;
            color: #8866cc;
            letter-spacing: 2px;
            margin-bottom: 8px;
        }

        .ghost-header .game-badge {
            display: inline-block;
            padding: 4px 14px;
            background: rgba(100, 68, 170, 0.1);
            border: 1px solid rgba(100, 68, 170, 0.3);
            border-radius: 20px;
            font-family: var(--font-retro);
            font-size: 0.5rem;
            color: #8866cc;
            letter-spacing: 1px;
            margin-bottom: 20px;
        }

        .ghost-breath-circle {
            width: 180px;
            height: 180px;
            border-radius: 50%;
            border: 3px solid rgba(100, 68, 170, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            margin: 16px 0;
            transition: all 0.3s;
            background: rgba(100, 68, 170, 0.05);
        }

        .ghost-breath-circle.active {
            border-color: #44ff88;
            background: rgba(68, 255, 136, 0.08);
            box-shadow: 0 0 40px rgba(68, 255, 136, 0.15);
            transform: scale(1.05);
        }

        .ghost-breath-circle .ghost-breath-icon {
            font-size: 3rem;
            margin-bottom: 8px;
        }

        .ghost-breath-circle .ghost-breath-label {
            font-family: var(--font-retro);
            font-size: 0.55rem;
            color: #8866cc;
            letter-spacing: 2px;
        }

        .ghost-breath-circle.active .ghost-breath-label {
            color: #44ff88;
        }

        .ghost-mic-bar {
            width: 80%;
            max-width: 260px;
            height: 14px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 7px;
            overflow: hidden;
            margin: 12px 0;
            border: 1px solid rgba(100, 68, 170, 0.2);
        }

        .ghost-mic-bar-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #6644aa, #8866cc);
            border-radius: 7px;
            transition: width 0.1s;
        }

        .ghost-mic-bar-fill.active {
            background: linear-gradient(90deg, #44ff88, #66ffaa);
        }

        .ghost-hint {
            font-size: 0.75rem;
            color: rgba(140, 120, 180, 0.6);
            margin-top: 12px;
            line-height: 1.5;
        }

        .ghost-status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            background: rgba(10, 8, 20, 0.9);
            border-top: 1px solid rgba(100, 68, 170, 0.15);
            font-size: 0.75rem;
        }

        .ghost-status-bar .connection {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-secondary);
        }
    </style>
</head>

<body>

    <!-- Connecting Screen -->
    <div class="connecting-screen" id="connecting-screen">
        <h2>CONNECTING...</h2>
        <p id="connect-message">Joining session...</p>
        <div class="loading-spinner"></div>
    </div>

    <!-- Waiting for Game Start -->
    <div class="waiting-overlay" id="waiting-overlay">
        <h2>âœ… CONNECTED!</h2>
        <p>Waiting for the host to start the game...</p>
        <p style="margin-top: 12px; color: var(--text-muted); font-size: 0.8rem;">Keep this screen open</p>
    </div>

    <!-- Main Controller (Gesture Mode â€” for rest-mode games) -->
    <div class="controller" id="controller" style="display: none;">
        <div class="ctrl-header">
            <h1>MOTION ARENA</h1>
            <div class="player-badge p1" id="player-badge">PLAYER ?</div>
        </div>

        <div class="camera-container">
            <video id="video" autoplay playsinline></video>
            <canvas id="canvas-overlay"></canvas>
            <div class="gesture-display">
                <div class="gesture-icon" id="gesture-icon">âœ‹</div>
                <div class="gesture-name" id="gesture-name">READY</div>
            </div>
        </div>

        <div class="status-bar">
            <div class="connection">
                <span class="status-dot connected" id="status-dot"></span>
                <span id="connection-text">Connected</span>
            </div>
            <div class="fps" id="fps-display">-- FPS</div>
        </div>
    </div>

    <!-- Motion Controller (Body Movement Mode â€” for active-mode games like Dino Dash) -->
    <div class="motion-controller" id="motion-controller">
        <div class="motion-header">
            <h1>âš”ï¸ KNIGHT DASH</h1>
            <div class="game-badge">BODY MOTION</div>
        </div>

        <div class="jump-zone" id="jump-zone">
            <div class="jump-icon" id="jump-icon">ðŸ¦˜</div>
            <div class="jump-label" id="jump-label">JUMP!</div>
        </div>

        <div class="accel-bar">
            <div class="accel-bar-fill" id="accel-bar-fill"></div>
        </div>

        <p class="motion-hint">Hold your phone and jump!<br>Your movement controls the dino.</p>

        <div class="jump-count" id="jump-count">JUMPS: 0</div>

        <div class="motion-status-bar">
            <div class="connection">
                <span class="status-dot connected" id="motion-status-dot"></span>
                <span id="motion-conn-text">Connected</span>
            </div>
        </div>
    </div>

    <!-- Ghost of the Breath Temple Controller (Mic-only Mode) -->
    <div class="ghost-controller" id="ghost-controller">
        <div class="ghost-header">
            <h1>ðŸ‘» GHOST OF THE BREATH TEMPLE</h1>
            <div class="game-badge">ðŸŽ¤ MIC ONLY</div>
        </div>

        <div class="ghost-breath-circle" id="ghost-breath-circle">
            <div class="ghost-breath-icon" id="ghost-breath-icon">ðŸŽ¤</div>
            <div class="ghost-breath-label" id="ghost-breath-label">INITIALIZING...</div>
        </div>

        <div class="ghost-mic-bar">
            <div class="ghost-mic-bar-fill" id="ghost-mic-fill"></div>
        </div>

        <p class="ghost-hint">Place phone near your nose<br>Breathe to send rhythm events ðŸ«</p>

        <div class="ghost-status-bar">
            <div class="connection">
                <span class="status-dot connected" id="ghost-status-dot"></span>
                <span id="ghost-conn-text">Connected</span>
            </div>
            <span id="ghost-mic-level" style="color: rgba(140,120,180,0.5);">MIC: --</span>
        </div>
    </div>



    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.min.js"></script>
    <script>
        const socket = io({
            transports: ['polling', 'websocket'],  // polling first (more reliable on mobile HTTPS with self-signed certs)
            reconnectionAttempts: 5,
            reconnectionDelay: 1000,
            timeout: 10000
        });
        const params = new URLSearchParams(window.location.search);
        const sessionId = params.get('session');

        // Connection status feedback on connecting screen
        const connectMsg = document.getElementById('connect-message');

        socket.on('connect', () => {
            console.log('[Controller] Socket connected:', socket.id);
            if (connectMsg && !sessionId) {
                connectMsg.textContent = 'Connected! No session ID found.';
            }
        });

        socket.on('connect_error', (err) => {
            console.error('[Controller] Connection error:', err.message);
            if (connectMsg) {
                connectMsg.textContent = `Connection error: ${err.message}`;
                connectMsg.classList.add('error');
            }
        });

        socket.on('disconnect', (reason) => {
            console.warn('[Controller] Disconnected:', reason);
        });

        socket.on('reconnect_attempt', (attempt) => {
            console.log('[Controller] Reconnecting... attempt', attempt);
            if (connectMsg) {
                connectMsg.textContent = `Reconnecting... (attempt ${attempt})`;
            }
        });

        socket.on('reconnect_failed', () => {
            if (connectMsg) {
                connectMsg.textContent = 'Could not connect to server. Check WiFi and try refreshing.';
                connectMsg.classList.add('error');
            }
        });

        let playerNum = null;
        let gameStarted = false;
        let currentGame = null; // will be set after join

        // === REFINED GESTURE ENGINE ===
        // Gesture state
        let lastSentAction = null;
        let lastSentTime = 0;
        let gestureHistory = [];       // Buffer of last N detected gestures
        const STABILITY_FRAMES = 3;    // Frames a gesture must be consistent before triggering
        const REPEAT_INTERVAL = {      // How fast held gestures repeat
            'MOVE_LEFT': 150,
            'MOVE_RIGHT': 150,
            'ROTATE': 300,
            'DROP': 120
        };
        const NO_HAND_THRESHOLD = 12;

        const gestureMap = {
            'thumb_left': { action: 'MOVE_LEFT', icon: 'ðŸ‘ˆ', name: 'LEFT' },
            'index_up': { action: 'MOVE_RIGHT', icon: 'â˜ï¸', name: 'RIGHT' },
            'shaka': { action: 'ROTATE', icon: 'ðŸ¤™', name: 'ROTATE' },
            'open_palm': { action: 'DROP', icon: 'âœ‹', name: 'DROP' }
        };

        // === ANGLE-BASED FINGER DETECTION ===
        function angleBetween(a, b, c) {
            // Angle at point b formed by segments ba and bc (in radians)
            const ba = { x: a.x - b.x, y: a.y - b.y, z: (a.z || 0) - (b.z || 0) };
            const bc = { x: c.x - b.x, y: c.y - b.y, z: (c.z || 0) - (b.z || 0) };
            const dot = ba.x * bc.x + ba.y * bc.y + ba.z * bc.z;
            const magBA = Math.sqrt(ba.x ** 2 + ba.y ** 2 + ba.z ** 2);
            const magBC = Math.sqrt(bc.x ** 2 + bc.y ** 2 + bc.z ** 2);
            if (magBA === 0 || magBC === 0) return 0;
            const cosAngle = Math.max(-1, Math.min(1, dot / (magBA * magBC)));
            return Math.acos(cosAngle) * (180 / Math.PI);
        }

        function isFingerExtended(landmarks, finger) {
            // Finger indices: [MCP, PIP, DIP, TIP]
            const fingers = {
                index: [5, 6, 7, 8],
                middle: [9, 10, 11, 12],
                ring: [13, 14, 15, 16],
                pinky: [17, 18, 19, 20]
            };

            const ids = fingers[finger];
            if (!ids) return false;

            const mcp = landmarks[ids[0]];
            const pip = landmarks[ids[1]];
            const dip = landmarks[ids[2]];
            const tip = landmarks[ids[3]];

            // Curl angle at PIP joint (MCP â†’ PIP â†’ DIP)
            const pipAngle = angleBetween(mcp, pip, dip);
            // Curl angle at DIP joint (PIP â†’ DIP â†’ TIP)
            const dipAngle = angleBetween(pip, dip, tip);

            // Extended = both joints relatively straight (> 140Â°)
            // Curled = at least one joint bent (< 100Â°)
            return pipAngle > 140 && dipAngle > 140;
        }

        function isThumbExtended(landmarks) {
            const cmc = landmarks[1];  // CMC joint
            const mcp = landmarks[2];  // MCP joint
            const ip = landmarks[3];   // IP joint
            const tip = landmarks[4];  // Tip
            const wrist = landmarks[0];

            // Angle at MCP (CMC â†’ MCP â†’ IP)
            const mcpAngle = angleBetween(cmc, mcp, ip);
            // Distance from tip to wrist vs IP to wrist
            const tipDist = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
            const ipDist = Math.hypot(ip.x - wrist.x, ip.y - wrist.y);

            // Thumb is extended if MCP angle is wide AND tip is farther from wrist than IP
            return mcpAngle > 140 && tipDist > ipDist * 1.1;
        }

        function detectGesture(landmarks) {
            const thumb = isThumbExtended(landmarks);
            const index = isFingerExtended(landmarks, 'index');
            const middle = isFingerExtended(landmarks, 'middle');
            const ring = isFingerExtended(landmarks, 'ring');
            const pinky = isFingerExtended(landmarks, 'pinky');

            // Debug: update finger state display (shown in gesture name area when debugging)
            const fingerState = `${thumb ? 'T' : '_'}${index ? 'I' : '_'}${middle ? 'M' : '_'}${ring ? 'R' : '_'}${pinky ? 'P' : '_'}`;

            // FIST: all fingers curled â€” now idle (no action)
            if (!thumb && !index && !middle && !ring && !pinky) {
                return { gesture: 'fist', debug: fingerState };
            }

            // INDEX UP: only index extended (thumb may or may not be out)
            if (index && !middle && !ring && !pinky) {
                return { gesture: 'index_up', debug: fingerState };
            }

            // SHAKA: thumb and pinky extended, others curled (must check BEFORE thumb_left)
            if (thumb && !index && !middle && !ring && pinky) {
                return { gesture: 'shaka', debug: fingerState };
            }

            // THUMB LEFT: only thumb extended, all others curled
            if (thumb && !index && !middle && !ring && !pinky) {
                return { gesture: 'thumb_left', debug: fingerState };
            }

            // OPEN PALM: all fingers extended â€” DROP gesture
            if (thumb && index && middle && ring && pinky) {
                return { gesture: 'open_palm', debug: fingerState };
            }

            return { gesture: null, debug: fingerState };
        }

        // === GESTURE STABILITY & SENDING ===
        function processGesture(rawGesture) {
            // Add to history buffer
            gestureHistory.push(rawGesture);
            if (gestureHistory.length > STABILITY_FRAMES) {
                gestureHistory.shift();
            }

            // Check if all recent frames agree
            if (gestureHistory.length < STABILITY_FRAMES) return;
            const allSame = gestureHistory.every(g => g === gestureHistory[0]);
            if (!allSame) return;

            const stableGesture = gestureHistory[0];
            if (!stableGesture) return; // Unknown gesture, don't act

            const mapping = gestureMap[stableGesture];
            if (!mapping) return; // No mapping for this gesture (e.g., open_palm)

            const now = Date.now();
            const action = mapping.action;

            // If it's the same action, check repeat interval
            if (action === lastSentAction) {
                const interval = REPEAT_INTERVAL[action] || 200;
                if (now - lastSentTime < interval) return;
            }

            // Send!
            document.getElementById('gesture-icon').textContent = mapping.icon;
            document.getElementById('gesture-name').textContent = mapping.name;

            if (gameStarted) {
                socket.emit('gesture', { action });
            }

            lastSentAction = action;
            lastSentTime = now;
        }

        function processNoHand() {
            // No hand = idle, do nothing (DROP is now open palm gesture)
            document.getElementById('gesture-icon').textContent = 'ðŸ‘‹';
            document.getElementById('gesture-name').textContent = 'NO HAND';
            lastSentAction = null;
            gestureHistory = [];
        }

        // === SESSION MANAGEMENT ===
        // Join session â€” MUST wait for socket to connect first
        function joinSession() {
            if (!sessionId) {
                document.getElementById('connect-message').textContent = 'No session ID found!';
                document.getElementById('connect-message').classList.add('error');
                return;
            }

            document.getElementById('connect-message').textContent = 'Joining session...';

            socket.emit('join-session', { sessionId }, (response) => {
                if (response.error) {
                    document.getElementById('connect-message').textContent = response.error;
                    document.getElementById('connect-message').classList.add('error');
                    return;
                }

                playerNum = response.playerNum;
                currentGame = response.game;
                document.getElementById('connecting-screen').style.display = 'none';
                document.getElementById('waiting-overlay').classList.add('visible');

                // Set player badge
                const badge = document.getElementById('player-badge');
                badge.textContent = `PLAYER ${playerNum}`;
                badge.className = `player-badge p${playerNum}`;
            });
        }

        // Wait for connection, then join
        if (socket.connected) {
            joinSession();
        } else {
            socket.on('connect', joinSession);
        }

        // Game started â€” show appropriate controller based on game type
        socket.on('game-started', () => {
            gameStarted = true;
            document.getElementById('waiting-overlay').classList.remove('visible');

            if (currentGame === 'ghost-breath') {
                // Ghost Breath: mic-only breath detection
                document.getElementById('ghost-controller').classList.add('visible');
                initGhostBreathController();
            } else if (currentGame === 'dino-dash') {
                // Active mode: use body motion controller
                document.getElementById('motion-controller').classList.add('visible');
                initMotionController();

            } else {
                // Rest mode: use gesture camera controller
                document.getElementById('controller').style.display = 'flex';
                initCamera();
            }
        });

        // Session ended
        socket.on('session-ended', (data) => {
            alert(data.reason || 'Session ended');
            window.location.href = '/';
        });

        // === CAMERA + MEDIAPIPE ===
        function initCamera() {
            const video = document.getElementById('video');
            const canvasOverlay = document.getElementById('canvas-overlay');
            const ctx = canvasOverlay.getContext('2d');

            let frameCount = 0;
            let lastFpsTime = Date.now();
            let noHandFrames = 0;

            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`
            });

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 0,
                minDetectionConfidence: 0.6,
                minTrackingConfidence: 0.5
            });

            hands.onResults((results) => {
                // FPS counter
                frameCount++;
                const now = Date.now();
                if (now - lastFpsTime >= 1000) {
                    document.getElementById('fps-display').textContent = `${frameCount} FPS`;
                    frameCount = 0;
                    lastFpsTime = now;
                }

                // Resize canvas to match video
                canvasOverlay.width = canvasOverlay.clientWidth;
                canvasOverlay.height = canvasOverlay.clientHeight;
                ctx.clearRect(0, 0, canvasOverlay.width, canvasOverlay.height);

                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    noHandFrames = 0;
                    const landmarks = results.multiHandLandmarks[0];

                    // Draw hand landmarks
                    drawHand(ctx, landmarks, canvasOverlay.width, canvasOverlay.height);

                    // Detect gesture using angle-based detection
                    const result = detectGesture(landmarks);
                    processGesture(result.gesture);
                } else {
                    // No hand detected
                    noHandFrames++;
                    if (noHandFrames >= NO_HAND_THRESHOLD) {
                        processNoHand();
                    }
                }
            });

            const camera = new Camera(video, {
                onFrame: async () => {
                    await hands.send({ image: video });
                },
                width: 640,
                height: 480,
                facingMode: 'user'
            });

            camera.start();
        }

        // Draw hand landmarks
        function drawHand(ctx, landmarks, w, h) {
            // Mirror the X coordinates since video is mirrored
            const connections = [
                [0, 1], [1, 2], [2, 3], [3, 4],
                [0, 5], [5, 6], [6, 7], [7, 8],
                [0, 9], [9, 10], [10, 11], [11, 12],
                [0, 13], [13, 14], [14, 15], [15, 16],
                [0, 17], [17, 18], [18, 19], [19, 20],
                [5, 9], [9, 13], [13, 17]
            ];

            ctx.strokeStyle = 'rgba(0, 229, 255, 0.6)';
            ctx.lineWidth = 2;

            for (const [i, j] of connections) {
                ctx.beginPath();
                ctx.moveTo((1 - landmarks[i].x) * w, landmarks[i].y * h);
                ctx.lineTo((1 - landmarks[j].x) * w, landmarks[j].y * h);
                ctx.stroke();
            }

            for (let i = 0; i < landmarks.length; i++) {
                const x = (1 - landmarks[i].x) * w;
                const y = landmarks[i].y * h;
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, 2 * Math.PI);
                ctx.fillStyle = i === 0 ? 'var(--accent-magenta)' : 'rgba(0, 229, 255, 0.9)';
                ctx.fill();
            }
        }

        // Disconnect handling
        socket.on('disconnect', () => {
            document.getElementById('status-dot').className = 'status-dot disconnected';
            document.getElementById('connection-text').textContent = 'Disconnected';
            if (document.getElementById('motion-status-dot')) {
                document.getElementById('motion-status-dot').className = 'status-dot disconnected';
                document.getElementById('motion-conn-text').textContent = 'Disconnected';
            }
        });

        socket.on('connect', () => {
            document.getElementById('status-dot').className = 'status-dot connected';
            document.getElementById('connection-text').textContent = 'Connected';
            if (document.getElementById('motion-status-dot')) {
                document.getElementById('motion-status-dot').className = 'status-dot connected';
                document.getElementById('motion-conn-text').textContent = 'Connected';
            }
        });

        // ============================================
        // KNIGHT DASH â€” MOTION CONTROLLER (Accelerometer)
        // ============================================
        function initMotionController() {
            let jumpCount = 0;
            let lastJumpTime = 0;
            const JUMP_COOLDOWN = 500; // ms
            const JUMP_THRESHOLD = 15; // m/sÂ² acceleration spike
            let accelSamples = [];
            const SAMPLE_WINDOW = 5;

            const jumpZone = document.getElementById('jump-zone');
            const jumpIcon = document.getElementById('jump-icon');
            const jumpLabel = document.getElementById('jump-label');
            const accelBarFill = document.getElementById('accel-bar-fill');
            const jumpCountEl = document.getElementById('jump-count');

            function triggerJump() {
                const now = Date.now();
                if (now - lastJumpTime < JUMP_COOLDOWN) return;
                lastJumpTime = now;

                jumpCount++;
                jumpCountEl.textContent = `JUMPS: ${jumpCount}`;

                // Visual feedback
                jumpZone.classList.add('active');
                jumpIcon.textContent = 'ðŸ¦•';
                jumpLabel.textContent = 'JUMP!';
                setTimeout(() => {
                    jumpZone.classList.remove('active');
                    jumpIcon.textContent = 'ðŸ¦˜';
                    jumpLabel.textContent = 'READY';
                }, 300);

                // Send jump event to server
                if (gameStarted) {
                    socket.emit('gesture', { action: 'JUMP' });
                }
            }

            // Request permission for iOS 13+
            if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                // iOS â€” need user gesture to request permission
                jumpZone.addEventListener('click', async () => {
                    try {
                        const permission = await DeviceMotionEvent.requestPermission();
                        if (permission === 'granted') {
                            startMotionListening();
                        }
                    } catch (e) {
                        console.warn('Motion permission denied:', e);
                    }
                }, { once: true });

                // Show tap hint for iOS
                jumpLabel.textContent = 'TAP TO ENABLE';
            } else {
                // Android / desktop â€” no permission needed
                startMotionListening();
            }

            function startMotionListening() {
                window.addEventListener('devicemotion', (event) => {
                    const accel = event.accelerationIncludingGravity;
                    if (!accel) return;

                    // Total acceleration magnitude (minus gravity baseline ~9.8)
                    const totalAccel = Math.sqrt(accel.x ** 2 + accel.y ** 2 + accel.z ** 2);
                    const netAccel = Math.abs(totalAccel - 9.8);

                    // Rolling average to smooth out noise
                    accelSamples.push(netAccel);
                    if (accelSamples.length > SAMPLE_WINDOW) accelSamples.shift();
                    const avgAccel = accelSamples.reduce((a, b) => a + b, 0) / accelSamples.length;

                    // Update visual bar (0 to JUMP_THRESHOLD = 100%)
                    const pct = Math.min(100, (avgAccel / JUMP_THRESHOLD) * 100);
                    accelBarFill.style.width = pct + '%';

                    // Detect jump
                    if (avgAccel > JUMP_THRESHOLD) {
                        triggerJump();
                    }
                });
            }

            // Fallback: tap to jump (for testing or when sensors unavailable)
            jumpZone.addEventListener('click', () => {
                triggerJump();
            });
        }

        // ============================================
        // GHOST BREATH â€” BREATH CONTROLLER (Mic only)
        // ============================================
        function initGhostBreathController() {
            const breathCircle = document.getElementById('ghost-breath-circle');
            const breathIcon = document.getElementById('ghost-breath-icon');
            const breathLabel = document.getElementById('ghost-breath-label');
            const micFill = document.getElementById('ghost-mic-fill');
            const micLevelText = document.getElementById('ghost-mic-level');

            let noiseFloor = 0.02;
            let calibrationSamples = [];
            let calibrated = false;
            let smoothedRms = 0;
            let rmsSamples = [];
            const SMOOTH_WINDOW = 10;
            let breathActive = false;
            let breathStartTime = 0;
            const MIN_BREATH_DURATION = 120; // ms
            const BREATH_THRESHOLD_MUL = 2.0;
            const RELEASE_MUL = 1.3;
            const CALIBRATION_COUNT = 90;

            async function initMic() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false
                        }
                    });
                    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    const source = audioCtx.createMediaStreamSource(stream);
                    const analyser = audioCtx.createAnalyser();
                    analyser.fftSize = 512;
                    analyser.smoothingTimeConstant = 0.3;
                    source.connect(analyser);

                    const dataArray = new Float32Array(analyser.fftSize);

                    breathLabel.textContent = 'CALIBRATING...';
                    breathIcon.textContent = 'â³';

                    function processAudio() {
                        analyser.getFloatTimeDomainData(dataArray);
                        let sum = 0;
                        for (let i = 0; i < dataArray.length; i++) {
                            sum += dataArray[i] * dataArray[i];
                        }
                        const rawRms = Math.sqrt(sum / dataArray.length);

                        // Smooth
                        rmsSamples.push(rawRms);
                        if (rmsSamples.length > SMOOTH_WINDOW) rmsSamples.shift();
                        smoothedRms = rmsSamples.reduce((a, b) => a + b, 0) / rmsSamples.length;

                        // Calibration
                        if (!calibrated) {
                            calibrationSamples.push(rawRms);
                            const progress = Math.round((calibrationSamples.length / CALIBRATION_COUNT) * 100);
                            breathLabel.textContent = `CALIBRATING ${progress}%`;
                            micFill.style.width = progress + '%';

                            if (calibrationSamples.length >= CALIBRATION_COUNT) {
                                const sorted = [...calibrationSamples].sort((a, b) => a - b);
                                const median = sorted[Math.floor(sorted.length / 2)];
                                noiseFloor = Math.max(median * BREATH_THRESHOLD_MUL, 0.003);
                                calibrated = true;
                                breathLabel.textContent = 'READY â€” BREATHE';
                                breathIcon.textContent = 'ðŸŽ¤';
                            }
                            requestAnimationFrame(processAudio);
                            return;
                        }

                        // Breath detection with hysteresis
                        const now = Date.now();
                        const breathThreshold = noiseFloor;
                        const releaseThreshold = noiseFloor * (RELEASE_MUL / BREATH_THRESHOLD_MUL);

                        if (!breathActive && smoothedRms > breathThreshold) {
                            breathActive = true;
                            breathStartTime = now;
                            breathCircle.classList.add('active');
                            micFill.classList.add('active');
                            breathLabel.textContent = 'BREATHING...';
                            breathIcon.textContent = 'ðŸ«';
                        } else if (breathActive && smoothedRms < releaseThreshold) {
                            const duration = now - breathStartTime;
                            if (duration >= MIN_BREATH_DURATION) {
                                // Valid breath â€” send event to game
                                socket.emit('breath-event', { timestamp: now });
                                breathLabel.textContent = 'âœ“ BREATH SENT';
                                setTimeout(() => {
                                    if (!breathActive) {
                                        breathLabel.textContent = 'READY â€” BREATHE';
                                    }
                                }, 400);
                            }
                            breathActive = false;
                            breathCircle.classList.remove('active');
                            micFill.classList.remove('active');
                            breathIcon.textContent = 'ðŸŽ¤';
                        }

                        // Update mic level bar
                        const level = Math.min(1.0, smoothedRms / (noiseFloor * 3));
                        micFill.style.width = (level * 100) + '%';
                        micLevelText.textContent = `MIC: ${Math.round(level * 100)}%`;

                        requestAnimationFrame(processAudio);
                    }

                    requestAnimationFrame(processAudio);

                } catch (err) {
                    console.warn('Mic access failed:', err);
                    breathLabel.textContent = 'MIC ERROR';
                    breathIcon.textContent = 'âŒ';
                }
            }

            initMic();
        }


    </script>

</body>

</html>
