<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Motion Arena AI — Gesture Tetris</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Rajdhani:wght@400;600;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="/src/style.css">
    <style>
        *,
        *::before,
        *::after {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #0a0a1a;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <canvas id="game-canvas"></canvas>

    <script type="module">
        // ═══════════════════════════════════════════════════
        // IMPORTS
        // ═══════════════════════════════════════════════════
        import { MultiplayerManager } from './src/game/MultiplayerManager.js';
        import { CanvasRenderer } from './src/ui/CanvasRenderer.js';
        import { SoundEngine } from './src/core/SoundEngine.js';
        import { WS_PORT } from './src/core/Constants.js';

        // ═══════════════════════════════════════════════════
        // STATE
        // ═══════════════════════════════════════════════════
        const canvas = document.getElementById('game-canvas');
        const renderer = new CanvasRenderer(canvas);
        const manager = new MultiplayerManager();
        const sound = new SoundEngine();

        let ws = null;
        let wsState = 'disconnected';
        let sessionId = null;
        let showDebug = false;
        let reconnectDelay = 1000;
        let connectedSockets = 0;
        let lastMessage = '';
        let p1Gesture = '—';
        let p2Gesture = '—';
        let p1QueueSize = 0;
        let p2QueueSize = 0;
        let inputsProcessed = 0;
        let inputsDropped = 0;
        let latency = 0;
        let lastPingTs = 0;

        // FPS tracking
        let frameCount = 0;
        let fpsTimer = 0;
        let fps = 60;

        // ═══════════════════════════════════════════════════
        // WEBSOCKET CONNECTION
        // ═══════════════════════════════════════════════════
        function connectWS() {
            try {
                // FIX: Connect directly to the game server (not through Vite proxy)
                // In dev, Vite runs on 5173 and game server on 3001
                const wsHost = location.hostname || 'localhost';
                const wsPort = WS_PORT; // 3001 — direct to game server
                const wsProto = 'ws'; // game client connects locally via HTTP
                const url = `${wsProto}://${wsHost}:${wsPort}/?role=game`;

                console.log(`[Game] Connecting to ${url}`);
                ws = new WebSocket(url);
                wsState = 'connecting';

                ws.onopen = () => {
                    console.log('[Game] ✓ WebSocket OPEN');
                    wsState = 'connected';
                    reconnectDelay = 1000;

                    // Heartbeat
                    setInterval(() => {
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            lastPingTs = Date.now();
                            ws.send(JSON.stringify({ type: 'heartbeat', ts: lastPingTs }));
                        }
                    }, 3000);
                };

                ws.onmessage = (e) => {
                    try {
                        const msg = JSON.parse(e.data);
                        lastMessage = msg.type;

                        // ── Welcome ──
                        if (msg.type === 'welcome') {
                            sessionId = msg.sessionId;
                            console.log(`[Game] Welcome — session=${sessionId} role=${msg.role}`);
                        }

                        // ── Heartbeat ACK ──
                        if (msg.type === 'heartbeatAck') {
                            latency = Date.now() - lastPingTs;
                        }

                        // ── Player Join ──
                        if (msg.type === 'playerJoin') {
                            console.log(`[Game] Player ${msg.player} JOINED`);
                            manager.playerJoin(msg.player);
                            sound.playerJoin();
                        }

                        // ── Player Leave ──
                        if (msg.type === 'playerLeave') {
                            console.log(`[Game] Player ${msg.player} LEFT`);
                            manager.playerLeave(msg.player);
                        }

                        // ── Session Update (player states) ──
                        if (msg.type === 'sessionUpdate') {
                            connectedSockets = msg.connectedSockets || 0;
                            // Sync connection status from server
                            if (msg.players) {
                                if (msg.players.P1) {
                                    if (msg.players.P1.connected && !manager.player1Connected) manager.playerJoin(1);
                                    if (!msg.players.P1.connected && manager.player1Connected) manager.playerLeave(1);
                                }
                                if (msg.players.P2) {
                                    if (msg.players.P2.connected && !manager.player2Connected) manager.playerJoin(2);
                                    if (!msg.players.P2.connected && manager.player2Connected) manager.playerLeave(2);
                                }
                            }
                        }

                        // ── START GAME — the critical event ──
                        if (msg.type === 'startGame') {
                            console.log('[Game] ★ startGame received! Starting countdown...');
                            manager.startCountdown();
                        }

                        // ── Command (gesture/action from controller) ──
                        if (msg.type === 'command') {
                            const p = msg.player;
                            const action = msg.action;
                            console.log(`[Game] Command P${p}:${action} lat=${Date.now() - (msg.ts || 0)}ms`);

                            if (p === 1) p1Gesture = action;
                            if (p === 2) p2Gesture = action;

                            // Execute the action in the game engine
                            manager.execAction(p, action);
                            inputsProcessed++;

                            // Sound feedback
                            if (action === 'ROTATE') sound.rotate();
                            else if (action === 'DROP') sound.drop();
                            else sound.move();
                        }

                        // ── Pause ──
                        if (msg.type === 'pauseGame') {
                            console.log(`[Game] Paused: ${msg.reason}`);
                            manager.pause(msg.reason);
                        }

                        // ── Game Reset ──
                        if (msg.type === 'gameReset') {
                            console.log('[Game] Reset received');
                            manager.reset();
                        }

                        // ── Leaderboard Update ──
                        if (msg.type === 'leaderboardUpdate') {
                            // Store for game over overlay
                            manager._leaderboard = msg.leaderboard;
                        }

                    } catch (err) {
                        console.error('[Game] Message parse error:', err);
                    }
                };

                ws.onclose = () => {
                    console.log('[Game] WebSocket CLOSED — reconnecting...');
                    wsState = 'disconnected';
                    setTimeout(connectWS, reconnectDelay);
                    reconnectDelay = Math.min(reconnectDelay * 1.5, 8000);
                };

                ws.onerror = (err) => {
                    console.error('[Game] WebSocket error');
                };

            } catch (err) {
                console.error('[Game] Connection failed:', err);
                setTimeout(connectWS, reconnectDelay);
            }
        }

        // ═══════════════════════════════════════════════════
        // KEYBOARD INPUT (fallback for testing without phones)
        // ═══════════════════════════════════════════════════
        document.addEventListener('keydown', (e) => {
            // Activate audio context on first interaction
            sound._ensureCtx();

            // G = toggle debug overlay
            if (e.key === 'g' || e.key === 'G') {
                showDebug = !showDebug;
                return;
            }

            // M = toggle mute
            if (e.key === 'm' || e.key === 'M') {
                sound.toggle();
                return;
            }

            // R = reset game
            if (e.key === 'r' || e.key === 'R') {
                manager.reset();
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'resetGame' }));
                }
                return;
            }

            // SPACE = force start (for testing)
            if (e.key === ' ') {
                e.preventDefault();
                if (manager.state === 'lobby') {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({ type: 'forceStart' }));
                    }
                }
                return;
            }

            // Game playing — keyboard controls for local testing
            if (manager.state === 'playing') {
                // P1 = WASD
                if (e.key === 'a' || e.key === 'A') manager.execAction(1, 'LEFT');
                if (e.key === 'd' || e.key === 'D') manager.execAction(1, 'RIGHT');
                if (e.key === 's' || e.key === 'S') manager.execAction(1, 'DOWN');
                if (e.key === 'w' || e.key === 'W') manager.execAction(1, 'ROTATE');
                if (e.key === 'q' || e.key === 'Q') manager.execAction(1, 'DROP');

                // P2 = Arrows
                if (e.key === 'ArrowLeft') { e.preventDefault(); manager.execAction(2, 'LEFT'); }
                if (e.key === 'ArrowRight') { e.preventDefault(); manager.execAction(2, 'RIGHT'); }
                if (e.key === 'ArrowDown') { e.preventDefault(); manager.execAction(2, 'DOWN'); }
                if (e.key === 'ArrowUp') { e.preventDefault(); manager.execAction(2, 'ROTATE'); }
                if (e.key === 'Enter') { e.preventDefault(); manager.execAction(2, 'DROP'); }
            }
        });

        // ═══════════════════════════════════════════════════
        // GAME LOOP
        // ═══════════════════════════════════════════════════
        let lastTime = performance.now();

        function gameLoop(now) {
            const deltaMs = now - lastTime;
            lastTime = now;

            // FPS counter
            frameCount++;
            fpsTimer += deltaMs;
            if (fpsTimer >= 1000) {
                fps = frameCount;
                frameCount = 0;
                fpsTimer = 0;
            }

            // Update game state
            manager.update(deltaMs);

            // Get state snapshot with leaderboard attached
            const state = manager.getState();
            if (manager._leaderboard) state.leaderboard = manager._leaderboard;

            // Render
            const events = renderer.render(state, deltaMs);

            // Sound events from renderer
            if (events.countdown !== undefined) sound.countdown(events.countdown);
            if (events.lineClear1) sound.lineClear(1);
            if (events.lineClear2) sound.lineClear(1);
            if (events.combo1) sound.combo(events.combo1);
            if (events.combo2) sound.combo(events.combo2);
            if (events.garbage1) sound.garbage();
            if (events.garbage2) sound.garbage();
            if (events.gameOver) {
                sound.gameOver();
                // Send game over to server
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'gameOver',
                        p1Score: state.player1?.score || 0,
                        p1Lines: state.player1?.lines || 0,
                        p1Level: state.player1?.level || 1,
                        p2Score: state.player2?.score || 0,
                        p2Lines: state.player2?.lines || 0,
                        p2Level: state.player2?.level || 1,
                    }));
                }
            }

            // Debug overlay
            if (showDebug) {
                renderer.drawDebugOverlay({
                    sessionId: sessionId || '—',
                    wsState,
                    connectedSockets,
                    lastMessage,
                    p1Connected: manager.player1Connected,
                    p2Connected: manager.player2Connected,
                    p1Ready: state.gameState !== 'lobby',
                    p2Ready: state.gameState !== 'lobby',
                    fps,
                    latency,
                    p1Gesture,
                    p2Gesture,
                    p1QueueSize,
                    p2QueueSize,
                    inputsProcessed,
                    inputsDropped,
                });
            }

            requestAnimationFrame(gameLoop);
        }

        // ═══════════════════════════════════════════════════
        // RESIZE
        // ═══════════════════════════════════════════════════
        function onResize() {
            renderer.resize();
        }
        window.addEventListener('resize', onResize);
        onResize();

        // ═══════════════════════════════════════════════════
        // INIT
        // ═══════════════════════════════════════════════════
        console.log('[Game] Motion Arena AI — Game Client starting...');
        connectWS();
        requestAnimationFrame(gameLoop);
    </script>
</body>

</html>